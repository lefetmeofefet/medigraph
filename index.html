<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="graphshroom/libs/pixi/pixi-v5.1.3.min.js"></script>
    <script src="graphshroom/libs/isMobile/isMobile.js"></script>
    <!--<script src="graphshroom/libs/pixi/pixi-v5.1.3.min.js"></script>-->


    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            padding: 0;
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
        }
    </style>

    <script src="./popup.js" type="module"></script>
    <pop-up id="popup"></pop-up>
    <script type="module">
        import {create_graph} from "./graphshroom/graphshroom.js"

        // import graph from "./graph.js"
        //
        // let nodes = {}
        // for (let node of graph.nodes) {
        //     nodes[node.name] = node
        // }
        // graph.nodes = nodes
        // create_graph(document.querySelector("#graph-anchor"), graph)

        // import {parseBiopax} from "./biopaxer.js";
        import {parseBiopax} from "./biopaxer3.js";

        import {
            PathbankIbuprofen,
            ReactomeVitaminK,
            ReactomeHemostasis,
            PathbankVitaminK,
            PathbankWarfarin,
            ReactomeProstagladin,
        } from "./pathways.js";

        // Pathbank Prednisolone action
        // let xml = ReactomeVitaminK
        // let xml = PathbankVitaminK
        let xmls = [
            ReactomeProstagladin,
            ReactomeVitaminK,
            // PathbankVitaminK
        ]


        let graphSystem;
        let relevantNodes = new Set();
        let selectedNodes = new Set();

        const GREEN = 0x207035,
            RED = 0x802030,
            PROTEIN = 0xc08c49,
            CYAN = 0x008b8b,
            GREY = 0x323232,
            PURPLE = 0xaa0099,
            BLUE = 0x302080;

        parseBiopax(xmls, graph => {
            console.log("Graph: ", graph)
            for (let node of graph.nodes.values()) {
                node.position = {
                    x: Math.random() * 1000,
                    y: Math.random() * 1000,
                }
                node.color = GREEN;
                if (node.type === "Enzyme" || node.type === "SmallMolecule") {
                    node.color = GREY
                } else if (node.type === "EnzymeInstance") {
                    node.color = PROTEIN
                } else if (node.type === "BiochemicalReaction") {
                    node.color = CYAN
                } else if (node.type === "Complex") {
                    node.color = PURPLE
                }
            }
            create_graph(
                document.querySelector("#graph-anchor"),
                graph,
                {
                    onLoad: graph => {
                        graphSystem = graph;
                    },
                    onHover: node => {
                        console.log("Hovered over ", node)
                        node.faded = false;
                        let popup = document.querySelector("#popup");
                        if (!popup.isMouseInside) {
                            popup.popup(node)
                        }
                    },
                    onHoverOut: node => {
                        if (selectedNodes.size > 0 && !relevantNodes.has(node)) {
                            node.faded = true
                        }
                        let popup = document.querySelector("#popup");
                        if (!popup.state.data.clickable) {
                            popup.close()
                        }
                    },
                    onClick: clickedNode => {
                        clickedNode.selected = !clickedNode.selected;
                        if (clickedNode.selected) {
                            selectedNodes.add(clickedNode);
                        } else {
                            selectedNodes.delete(clickedNode);
                        }

                        relevantNodes.clear();
                        if (selectedNodes.size > 0) {
                            calculateRelevantNodes()
                        }

                        // Faded non-relevant nodes
                        if (selectedNodes.size > 0) {
                            for (let node of graphSystem.nodes) {
                                node.faded = !relevantNodes.has(node);
                            }
                        }

                        if (selectedNodes.size === 0) {
                            for (let node of graphSystem.nodes) {
                                node.faded = false
                            }
                        }
                    }
                }
            )
        })

        function calculateRelevantNodes() {
            let subgraphs = [];

            for (let selectedNode of selectedNodes) {
                let subgraph = new Set();

                // Forward pass
                let currentLayer = new Set([selectedNode]);
                while (currentLayer.size > 0) {
                    currentLayer.forEach(node => subgraph.add(node));
                    let nextNodes = [...currentLayer]
                        .map(node => node.outgoingEdges.map(edge => edge.destinationNode))
                        .flat()
                        .filter(node => !subgraph.has(node));
                    currentLayer = new Set(nextNodes);
                }

                // Backwards pass
                currentLayer = new Set([selectedNode]);
                while (currentLayer.size > 0) {
                    currentLayer.forEach(node => subgraph.add(node));
                    let nextNodes = [...currentLayer]
                        .map(node => node.incomingEdges.map(edge => edge.sourceNode))
                        .flat()
                        .filter(node => !subgraph.has(node));
                    currentLayer = new Set(nextNodes);
                }

                subgraphs.push(subgraph);
            }

            relevantNodes = new Set(
                [...graphSystem.nodes].filter(node => subgraphs.every(subgraph => subgraph.has(node)))
            )
        }

    </script>
</head>
<body>
<div id="graph-anchor"></div>
</body>
</html>